# 事务

数据库事务是指**作为单个逻辑单元**执行的一系列操作，要么全都执行，要么都不执行。

## 1、ACID

#### 1、原子性（Atomicity）

事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。

回滚可以用回滚日志来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。

### 2、一致性（Consistency）

数据库在事务执行前后都保持一致性状态。可以理解为应用系统从一个正确的状态到另一个正确的状态。

拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。

### 3、隔离性（Isolation）

一个事务所做的修改在最终提交以前，对其它事务是不可见的。

### 4、持久性（Durability）

一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。

---

事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：

- 只有满足一致性，事务的执行结果才是正确的。
- 在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。
- 在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。
- 事务满足持久化是为了能应对数据库崩溃的情况。

![1555385802197](C:\Users\csw\AppData\Roaming\Typora\typora-user-images\1555385802197.png)

# 2、分布式事务

分布式事务用于在分布式系统中保证不同节点之间的数据一致性。

分布式事务的实现主要有以下5中方案

- XA方案
- TCC方案
- 本地消息表
- 可靠消息最终一致性方案
- 最大努力通知

## 2.1、XA方案（2PC）

两阶段提交（Tow-phase Commit,2PC），通过引入协调者（Coordinate）来协调参与者的行为，并最终决定这些参与者是否要真正执行事务。

### 1、准备阶段

协调者向所有参与者节点发送Prepare请求，参与者节点接受到请求之后，会各自执行事务，并记录在Undo log 和 Redo Log中。如果事务执行成功，暂不提交，先向协调者返回“成功”消息。

### 2、提交阶段

如果事务在**每个**参与者上都执行成功，事务协调者发送通知让参与者提交事务；否则，协调者发送通知让参与者回滚日志。

可以用Spring + JTA来实现XA方案。

### 存在的问题

1. **同步阻塞**：所有事务参与者在等待其他参与者的时候都处于同步阻塞状态，无法进行其他操作，性能太低。
2. **单点问题**：协调者是整个XA模型的核心，一旦协调者挂了，特别是在阶段二发生故障，参与者收不到提交或是回滚通知，会导致所有参与者一直等待。
3. **丢失消息导致的数据不一致**：在阶段二，如果发生局部网络故障，一部分事务参与者收到了提交消息，另一部分事务参与者没收到，就导致了节点之间数据的不一致。
4. **容错性差：**任何一个节点失败，就要导致所有节点回滚，没有完善的容错机制。

## 2.2、TCC方案

TCC的全称是 Try、Confirm、Cancel。

一共有三个节点

### 1、Try阶段

对各个节点的资源做检测并对其**锁定或预留**。比如冻结部分库存，资金等。

### 2、Confirm阶段

若各个节点都执行成功，则在各个节点中**执行实际的操作**

### 3、Cancel阶段

如果任何一个节点出错的话，那么这里就要执行补偿，在try阶段执行成功的业务进行回滚。

### 存在问题

让整个系统的业务逻辑变得复杂，补偿操作是需要自己根据业务逻辑来自己实现代码进行补偿的，代码量比较大，也会让代码的维护变得困难

### 使用场景

一般用于转账、交易、支付等需要严格保证资金正确性的场景。

## 2.3、本地消息表

本地消息表与业务数据表处于同一个数据库中，这样就能利用本地事务来保证在对这两个表的操作满足事务特性，并且使用了消息队列来保证最终一致性。

大致流程如下

1. A 系统在自己本地一个事务里操作同时，插入一条数据到消息表；
2. 接着 A 系统将这个消息发送到 MQ 中去；
3. B 系统接收到消息之后，在一个事务里，往自己本地消息表里插入一条数据，同时执行其他的业务操作，如果这个消息已经被处理过了，那么此时这个事务会回滚，这样**保证不会重复处理消息**；
4. B 系统执行成功之后，就会更新自己本地消息表的状态以及 A 系统消息表的状态；
5. 如果 B 系统处理失败了，那么就不会更新消息表状态，那么此时 A 系统会定时扫描自己的消息表，如果有未处理的消息，会再次发送到 MQ 中去，让 B 再次处理；
6. 这个方案保证了最终一致性，哪怕 B 事务失败了，但是 A 会不断重发消息，直到 B 那边成功为止。

![1555397626783](C:\Users\csw\AppData\Roaming\Typora\typora-user-images\1555397626783.png)

### 存在问题

这个方案说实话最大的问题就在于**严重依赖于数据库的消息表来管理事务**啥的，会导致如果是高并发场景咋办呢？咋扩展呢？所以一般确实很少用。

## 2.4、可靠消息最终一致性方案

不用本地的消息表，直接基于MQ来实现事务。比如阿里的RocketMQ就支持消息事务。

大致流程如下：

1. A系统发送一个Prepared消息到MQ，如果发送失败，直接取消该操作。
2. 消息发送成功后，执行本地事务，将执行结果发送给MQ。若失败就告诉MQ进行回滚。
3. MQ收到确认消息之后，B系统会接收到确认消息，然后执行本地的事务。
4. MQ会自动定时轮询所有prepared消息（即没发送确认消息给MQ）并回调接口，询问该消息的本地事务的执行结果，是继续重试还是进行回滚？一般来说这里你就可以查下数据库看之前本地事务是否执行，如果回滚了，那么这里也回滚吧。这个就是避免可能本地事务执行成功了，而确认消息却发送失败了。
5. 若系统B的事务执行失败，就进行不断地重试，直到事务执行成功。

## 2.5、最大努力通知方案

1. 系统 A 本地事务执行完之后，发送个消息到 MQ；
2. 这里会有个专门消费 MQ 的**最大努力通知服务**，这个服务会消费 MQ 然后写入数据库中记录下来，或者是放入个内存队列也可以，接着调用系统 B 的接口；
3. 要是系统 B 执行成功就 ok 了；要是系统 B 执行失败了，那么最大努力通知服务就定时尝试重新调用系统 B，反复 N 次，最后还是不行就放弃。