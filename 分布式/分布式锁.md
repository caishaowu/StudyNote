# 什么是分布式锁？

在单机场景下，可以使用语言的内置锁，如synchronized，来实现进程同步。但是在分布式场景下，需要同步的进程可能位于不同的节点上，那么就需要使用分布式锁。

# 如何实现分布式锁？

## 1、Redis实现分布式锁

官方叫`RedLock`算法，是Redis官方支持的分布式锁

这个分布式锁有 3 个重要的考量点：

- 互斥（只能有一个客户端获取锁）
- 不能死锁
- 容错（只要大部分 redis 节点创建了这把锁就可以）

### **1.1、普通的分布式锁实现**

最普通的实现方式就是往redis里面set一个key，并给这个key设置一个过期时间。

```java
SET my:lock 随机值 NX PX 30000
```

`NX`：set if not exist，key 不存在才能 set成功。

`PX`：锁的有效时间，30000ms后自动解锁。

释放锁就是删除key，一般用 `lua`脚本删除，判断value一样才删除：

> ```java
> -- 删除锁的时候，找到 key 对应的 value，跟自己传过去的 value 做比较，如果是一样的才删除。
> if redis.call(&quot;get&quot;,KEYS[1]) == ARGV[1] then
>     return redis.call(&quot;del&quot;,KEYS[1])
> else
>     return 0
> end
> ```

为啥要用随机值呢？

因为如果因为某些原因，导致线程A执行的很慢很慢，规定时间到了都没执行完，这时候锁会自动释放，线程B就得到了锁，随后线程A执行完了任务，接着就执行 del key 指令，导致线程B得到的锁就被线程A给删除了。

所以，当我们在删除锁的时候，要判断该锁是否是当前线程持有的锁，再执行删除操作，但这又带来了一个新的问题，这两个都是独立操作，不是原子性的，所以这一块要用 `lua` 脚本来实现。

**存在的问题**：

- 单点故障：普通的redis单例实现，存在单点故障问题。
- 主从延迟：主从复制实现，如果主节点挂了，key 还没同步到从节点，然后进行主从切换，别人还是可以set key，从而拿到这个锁。

### 1.2、RedLock算法

这个场景是假设有一个 redis cluster，有 5 个 redis master 实例。然后执行如下步骤获取一把锁：

1. 获取当前时间戳，记录获取锁的开始时间，单位是毫秒；
2. 跟上面类似，轮流尝试在每个 master 节点上创建锁，过期时间较短，一般就几十毫秒；
3. 尝试在**大多数节点**上建立一个锁，比如 5 个节点就要求是 3 个节点 `n / 2 + 1`；
4. 客户端计算一个超时时间，如果建立锁的时间小于超时时间，就算建立成功了；
5. 要是锁建立失败了，那么就依次之前建立过的锁删除；
6. 只要别人建立了一把分布式锁，你就得**不断轮询去尝试获取锁**。

## ZooKeeper实现分布式锁

### 1、 Zookeeper 抽象模型

Zookeeper 提供了一种树形结构级的命名空间，/app1/p_1 节点的父节点为 /app1。



![1555384181545](C:\Users\csw\AppData\Roaming\Typora\typora-user-images\1555384181545.png)

### 2、节点类型

- 永久节点：不会因为会话结束或者超时而消失；
- 临时节点：如果会话结束或者超时就会消失；
- 有序节点：会在节点名的后面加一个数字后缀，并且是有序的，例如生成的有序节点为 /lock/node-0000000000，它的下一个有序节点则为 /lock/node-0000000001，以此类推。

### 3、监听器

为一个节点注册监听器，在节点状态发生改变时，会给客户端发送消息。

### 4、分布式锁实现

- 创建一个锁目录 /lock；
- 当一个客户端需要获取锁时，在 /lock 下创建临时的且有序的子节点；
- 客户端获取 /lock 下的子节点列表，**判断自己创建的子节点是否为当前子节点列表中序号最小的子节点**，如果是则认为获得锁；**否则监听自己的前一个子节点**，获得子节点的变更通知后重复此步骤直至获得锁；
- 执行业务代码，完成后，删除对应的子节点。

### 5、会话超时

如果一个已经获得锁的会话超时了，因为创建的是临时节点，所以该会话对应的临时节点会被删除，其它会话就可以获得锁了。可以看到，Zookeeper 分布式锁不会出现数据库的唯一索引实现的分布式锁释放锁失败问题。

## ZooKeeper和RedLock分布式锁的比较



|        |                        Redis                         |              ZooKeeper               |
| ------ | :--------------------------------------------------: | :----------------------------------: |
| 性能   |         需要不断地去尝试获取锁，性能开销较大         | 获取不到锁，注册个监听器，性能开销小 |
| 准确性 | 对正确性要求极高的场景下，RedLock 并不能保证正确性。 |                                      |
| 实用性 |                     实现比较复杂                     |               实现简单               |

