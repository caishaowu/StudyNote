## 1、什么是单例模式？

单例模式保证类只有一个实例，并且提供一个访问该实例的全局访问点。

**优点：**只生成一个实例，减少系统性能开销。当实例化一个对象需要比较多的资源时，则可以在应用启动时直接产生一个单例对象，将其永驻在内存中。

## 2、单例模式的几种实现方式

### 2.1、饿汉式

饿汉式单例模式中，static 变量会在类装载时初始化，此时没有线程安全问题。虚拟机只会装载一次该类。

```java
public class Singleton {
    
    private static Singleton uniqueInstance = new Singleton();
    
    private Singleton() {}
    
    public static Singleton getUniqueInstance() {
        return uniqueInstance;
    }
}
```

**优点：**线程安全，调用效率高

**缺点：**不能延时加载，可能造成资源浪费

### 2.2、懒汉式

```java
public class Singleton {
    
    private static Singleton uniqueInstance;
    
    private Singleton() {}
    
    public static synchronized Singleton getUniqueInstance() {
       if(uniqueInstance == null) {
           uniqueInstance = new Singleton();
       }
        return uniqueInstance;
    }
}
```

**优点：**支持延迟加载，资源利用率高

**缺点：**方法需要同步，并发效率低

### 2.3、双重校验锁

双重校验锁解决了懒汉式并发效率低的问题，只有在第一次获取该类实例时需要进行同步，极大提高了并发效率。

```java
public class Singleton {
    //防止指令重排
    private volatile static Singleton uniqueInstance;
    
    private Singleton() {}
    
    public static Singleton getUniqueInstance() { 
       if(uniqueInstance == null) {
           synchronized(Singleton.class) {
               if(uniqueInstance == null) {
                   uniqueInstance = new Singleton();
               }
           }
       }
        return uniqueInstance;
    }
}
```

这里为什么需要两条`if`语句呢？假设我们只有一条`if`语句

```java
if(uniqueInstance == null) {
    synchronized(Singleton.class) {
        uniqueInstance = new Singleton();
    }
}
```

考虑以下场景：在`uniqueInstance == null` 时，有两个线程同时执行了`if`语句，那么这两个线程就会进入到`if`语句块内，虽有语句块中有同步语句，但是在第一个线程执行完成后，对象实例已经被创建，此时第二个线程又创建了一个新的实例，问题就出现了。因此必须使用双重校验锁，也即需要两个`if`语句。

**注意：**uniqueInstance 采用`volatile` 关键字修饰是很有必要的， `uniqueInstance = new Singleton();`这段代码其实是分为三步执行的：

1. **为  uniqueInstance 分配内存空间**
2. **初始化 uniqueInstance** 
3. **将 uniqueInstance 指向分配的内存地址**

但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1 -> 3 -> 2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T<sub>1</sub> 执行了 1 和 3，此时 T<sub>2</sub> 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。

使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。

### 2.4、静态内部类

当 `Singleton` 类被加载时，静态内部类 `InnerClass`没有被加载进内存。只有当调用 `getUniqueInstance()`方法时，`InnerClass`才会被加载，此时初始化 `UNIQUEINSTANCE`实例，并且 JVM 能确保该实例只被实例化一次。

**优点：**可以延迟加载，且 JVM 提供了对线程安全的支持。

```java
public class Singleton {
    
    private Singleton() {
        
    }
    
    private static class InnerClass {
        private static final Singleton UNIQUEINSTANCE = new Singleton();
    }
    public static Singleton getUniqueInstance() {
        return InnerClass.UNIQUEINSTANCE;
    }
}
```

### 2.5、枚举

```java
public enum Singleton {
    //定义枚举元素，代表了一个Singleton实例
    UNIQUEINSTANCE;.
        
    public void singletonOperation() {
        //功能处理
    }
}
```

**优点：**实现简单；枚举本身就是单例，由 JVM 从根本上提供保障！避免通过反射和序列化的漏洞。

**缺点：**无法延时加载



## 3、单例模式的应用场景

