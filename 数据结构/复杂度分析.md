## 复杂度分析

​	数据结构和算法本身解决的是“快”和“省”的问题，执行效率是算法一个非常重要的考量指标。

### 为什么需要复杂度分析？

1. **测试结果非常依赖测试环境**，测试环境中的硬件不同会对测试结果又很大的影响。
2. **测试结果受数据规模的影响很大**，如果数据规模太小，测试结果可能无法真实地反映算法的性能。比如，对于小规模的数据排序，插入排序可能反倒会比快速排序快！。

所以，我们需要一个不用具体的测试数据来测试，就可以粗略地估算算法的执行效率的方法。

## 时间复杂度

时间复杂度的全称是渐进时间复杂度，表示**算法的执行时间与数据规模**之间的增长关系。

### 如何分析一段代码的时间复杂度？

1. 只关注循环执行次数最多的一段代码
2. 加法法则：总复杂度等于量级最大的那段代码的复杂度
3. 乘法法则：多重循环、递归

### 最好情况时间复杂度（best case time complexity）

顾名思义，最好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度。

### 最坏情况时间复杂度（worst case time complexity）

最坏情况时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度。

### 平均情况时间复杂度（average case time complexity）

最好情况时间复杂度和最坏情况时间复杂度对应的都是极端情况下的代码复杂度，发生的概率其实并不大。为了更好地表示平均情况下的复杂度，我们需要引入另一个概念：平均情况时间复杂度，后面我简称为平均时间复杂度。

#### 如何分析平均时间复杂度？

```java
// n 表示数组 array 的长度
int find(int[] array, int n, int x) {
	int i = 0;
	int pos = -1;
	for (; i < n; ++i) {
		if (array[i] == x) {
			pos = i;
			break;
		}
	}
	return pos;
}
```

我们知道，要查找的变量 x，要么在数组里，要么就不在数组里。假设在数组中与不在数组中的概率都为1/2。要查找的数据出现在0~n-1这n个位置的概率也是一样的，为1/n。所以，要查找的数据在这个数组出现在0~n-1 中任意位置的概率就是 1/(2n)

![1550976182382](C:\Users\csw\AppData\Roaming\Typora\typora-user-images\1550976182382.png)

这个值就是概率论中的加权平均值，也叫作期望值，所以平均时间复杂度的全称应该叫加权平均时间复杂度或者期望时间复杂度。

### 均摊时间复杂度（amortized time complexity）

```java
// array 表示一个长度为 n 的数组
// 代码中的 array.length 就等于 n
int[] array = new int[n];
int count = 0;
void insert(int val) {
	if (count == array.length) {
		int sum = 0;
		for (int i = 0; i < array.length; ++i) {
			sum = sum + array[i];
		}
		array[0] = sum;
		count = 1;
	}
	array[count] = val;
	++count;
}
```

上面代码我们可以用概率论的方法分析出平均时间复杂度，但是经过观察我们可以发现，每经过一次O(n)的操作，都会跟着 n-1 次 O(1)的操作，所以均摊下来，这一组连续的操作的均摊时间复杂度就是O(1)。

## 空间复杂度

空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示**算法的存储空间与数据规模之间**的增长关系。

```java
void print(int n) {
 int i = 0;
 int[] a = new int[n];
 for (i; i <n; ++i) {
 a[i] = i * i;
 }
 for (i = n-1; i >= 0; --i) {
 print out a[i]
 }
}
```

可以看到，第三行代码申请了一个大小为 n 的 int 整形数组，除此职位，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是 O(n)。