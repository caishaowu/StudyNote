[TOC]



## 1、垃圾回收器

如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。

![](D:\File\studyNote\images\collector.png)

图展示了7种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用。虚拟机所处的区域，则表示它是属于新生代收集器还是老年代收集器。

### 1.1、Serial收集器

1. 最基本、发展历史最悠久的收集器；
2. 单线程收集器：进行垃圾回收时会暂停所有线程直到GC完成
3. 与其他收集器的单线程比简单而高效，是虚拟机运行在 **Client 模式**下的默认新生代收集器。

![](D:\File\studyNote\images\serial.png)

​				Serial/Serial Old 收集器运行示意图

### 1.2、ParNew收集器

1. Serial 收集器的多线程版本
2. 运行在**Server模式**下的首选新生代收集器，其中一个与性能无关但很重要的原因是，除了 Serial 收集器外，目前（JDK1.7）只有它能与CMS 收集器配合工作。
3. 使用 -XX:+UserConcMarkSweepGC 选项后的默认新生代收集器，也可以使用 -XX:+UserParNewGC 选项来强制指定它。
4. 默认开启的收集线程数与 CPU 的数量相同，在 CPU 非常多的环境下，可以使用 -XX:ParallelGCThreads 参数来限制垃圾收集的线程数。

![](D:\File\studyNote\images\parnew.png)

### 1.3、Parallel Scavenge收集器

1. 新生代收集器，主要目标是达到一个可控制的吞吐量。所谓吞吐量就是运行用户代码的时间与 CPU总消耗时间的比值。	
2. 提供两个参数用于精确控制吞吐量，分别是 -XX:MaxGCPauseMillis 以及 -XX:GCTimeRatio 参数。前者用于控制最大垃圾收集停顿时间，后者可以直接设置吞吐量大小
3. MaxGCPauseMillis 参数允许的值是一个大于 0 的毫秒数，这个值并不是越小越好，GC 停顿时间缩短是以牺牲吞吐量的新生代空间来换取的：系统通过把新生代调小来缩短停顿时间，但这直接导致垃圾收集变得更加频繁，导致停顿时间虽然在下降，但吞吐量也降下来了。
4. GCTimeRatio 参数的值是一个大于 0 且 小于 100 的参数，也就是垃圾收集时间占总时间的比率。默认值为 99，就是允许最大 1% （即 1 / (1+99) ) 的垃圾收集时间。
5. 经常被称为 “吞吐量优先” 收集器。
6. -XX: +UseAdaptiveSizePolicy 参数，打开这个参数之后，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整新生代大小（-Xmn）、Eden 与 Survivor 区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数以提供最合适的停顿时间或者最大的吞吐量，这种调节方式成为 GC 自适应的调节策略。

### 1.4、Serial Old收集器

1. Serial 收集器的老年代版本，同样是单线程收集器，使用“标记-整理”算法。
2. 主要意义在于给 Client 模式下的虚拟机使用。如果在 Server 模式下，主要还有两大用途：一种用途是在 JDK.5以及之前的版本中与Parallel Scavenge收集器搭配使用，另一种用途就是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用。

![](D:\File\studyNote\images\serial old.png)

### 1.5、Parallel Old收集器

1. Parellel Scavenge 收集器的老年代版本，使用多线程和“标记-整理“算法。JDK 1.6 中才开始提供。
2. 在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。

![](D:\File\studyNote\images\parallel old.png)

### 1.6、CMS（Concurrent Mark Sweep）收集器

1. 以获取最短回收停顿时间为目标的收集器，基于“标记—清除”算法实现。

2. 运作过程分为4个步骤：

   - 初始标记（CMS initial mark）
   - 并发标记（CMS concurrent mark）
   - 重新标记（CMS remark）
   - 并发清除（CMS concurrent sweep）

   其中，初始标记、重新标记这两个步骤仍然需要"Stop The World"。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC RootsTracing的过程，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。

   整个过程中耗时最长的并发标记与并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，**CMS收集器的内存回收过程是与用户线程一起并发执行的**。

   ![](D:\File\studyNote\images\sweep mark.png)

3. 主要优点：并发收集、低停顿。

4. 主要缺点：

   1. **对 CPU 资源非常敏感**。在并发阶段，虽然不会导致用户线程停顿，但是会因为占用了一部分线程（或者说 CPU资源）而导致应用程序变慢，总吞吐量会降低。CMS默认启动的回收线程数是（CPU数量+3）/4，也就是当CPU在4个以上时，并发回收时垃圾收集线程不少于25%的CPU资源，并且随着CPU数量的增加而下降。但是当CPU不足4个（譬如2个）时，CMS对用户程序的影响就可能变得很大。虽然虚拟机听过了一种称为“增量式并发收集器”的CMS收集器变种来应付这种情况，但实践证明效果一般，已被声明为“deprecated”。

   2. **无法处理浮动垃圾**，可能出现 “Concurrent Mode Failure” 失败而导致另一次 Full GC。所谓浮动垃圾，就是在 CMS 并发清理阶段，用户线程还在运行着也会产生新的垃圾，而这部分垃圾是出现标记过程之后的，CMS 无法在当次收集中处理，只好留到下一次 GC 时再清理掉。

      由于在垃圾收集阶段用户线程还需要运行，所以我们需要**预留有足够的内存空间**给用户线程使用。在 JDK 1.5 的默认设置下，CMS 收集器当老年代使用了 68%的空间后会被激活，如果在应用中老年代增长不是太快，可以适当调高参数 **-XX:CMSInitiatingOccupancyFraction** 的值来提高百分比，以便降低内存回收次数从而获取更好的性能。在 JDK 1.6 中，CMS收集器的启动阈值已经提升至 92%。若**CMS 运行期间预留的内存不足，就会出现“Concurrent Mode Failure”**失败，这时**虚拟机将启动后备预案**：临时启用 Serial Old 收集器来重新进行年老带的垃圾收集，这样停顿时间就很长了。

   3. **产生大量空间碎片**，空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不**提前触发一次Full GC**。为了解决这个问题，CMS收集器提供了一个**-XX:+UseCMSCompactAtFullCollection**开关参数（默认就是开启的），用于在CMS收集器顶不住要进**行FullGC时开启内存碎片的合并整理**过程，内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间不得不变长。虚拟机设计者还提供了另外一个参数-XX:CMSFullGCsBeforeCompaction，这个参数是用于设置执行多少次不压缩的Full GC后，跟着来一次带压缩的（默认值为0，表示每次进入Full GC时都进行碎片整理）。



### 1.7、G1收集器

1. G1是一款**面向服务端应用**的垃圾收集器。HotSpot开发团队赋予它的使命是（在比较长期的）未来可以替换掉JDK 1.5中发布的CMS收集器。

2. 与其他GC收集器相比，G1具备如下特点。

   1. **并行与并发**：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。
   2. **分代收集**：G1可以不需要其他收集器配合就能独立管理整个GC堆，能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。
   3. **空间整合**：基于“标记-整理”算法实现，从局部（两个Region 之间）来看是基于“复制”算法实现的。**不会产生空间碎片**，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。
   4. **可预测的停顿：**可以建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。

3. 使用G1收集器时，Java堆的内存布局就与其他收集器有很大差别，它将整个Java堆**划分为多个大小相等的独立区域**（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。

4. G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地**避免在整个Java堆中进行全区域的垃圾收集**。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region（这也就是Garbage-First名称的来由）。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。

5. 在G1收集器中，Region之间的对象引用以及其他收集器中的新生代与老年代之间的对象引用，虚拟机都是**使用Remembered Set来避免全堆扫描**的。G1中**每个Region都有一个与之对应的Remembered Set**，虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference引用的对象是否处于不同的Region之中（在分代的例子中就是检查是否老年代中的对象引用了新生代中的对象），如果是，便通过CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set之中。当进行内存回收时，在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描也不会有遗漏。

6. 如果不计算维护Remembered Set的操作，G1收集器的运作大致可划分为以下几个步骤：

   1. 初始标记（Initial Marking）
   2. 并发标记（Concurrent Marking）
   3. 最终标记（Final Marking）
   4. 筛选回收（Live Data Counting and Evacuation）

   前几个步骤的运行过程和 CMS 有很多相似之处。

   ​	**初始标记**阶段仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这阶段需要停顿线程，但耗时很短。

   ​	**并发标记**阶段是从GC Root开始对堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行。

   ​	而**最终标记**阶段则是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停顿线程，但是可并行执行。

   ​	最后在**筛选回收**阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划，这个阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率

   ![](C:\Users\csw\Desktop\学习笔记\images\G1.png)

## 2、理解GC日志

```java
33.125:[GC[DefNew:3324K-＞152K（3712K），0.0025925 secs]3324K-＞152K（11904K），0.0031680 secs]
100.667:[Full GC[Tenured:0 K-＞210K（10240K），0.0149142secs]4603K-＞210K（19456K），[Perm:2999K-＞2999K（21248K）]，0.0150007 secs][Times:user=0.01 sys=0.00，real=0.02 secs]
```

​	最前面的数字“33.125：”和“100.667：”代表了GC发生的时间，这个数字的含义是从Java虚拟机启动以来经过的秒数。

​	GC日志开头的"[GC"和"[Full GC"说明了这次垃圾收集的停顿类型，而不是用来区分新生代GC还是老年代GC的。如果有"Full"，说明这次GC是发生了Stop-The-World的，例如下面这段新生代收集器ParNew的日志也会出现"[Full GC"（这一般是因为出现了分配担保失败之类的问题，所以才导致STW）。如果是调用System.gc()方法所触发的收集，那么在这里将显示"[Full GC（System）"。

```java
[Full GC 283.736:[ParNew:261599K-＞261599K（261952K），0.0000288 secs]
```

​	接下来的"[DefNew"、"[Tenured"、"[Perm"表示GC发生的区域，这里显示的区域名称与使用的GC收集器是密切相关的，例如上面样例所使用的Serial收集器中的新生代名为"Default New Generation"，所以显示的是"[DefNew"。如果是ParNew收集器，新生代名称就会变为"[ParNew"，意为"Parallel New Generation"。如果采用Parallel Scavenge收集器，那它配套的新生代称为"PSYoungGen"，老年代和永久代同理，名称也是由收集器决定的。

​	后面方括号内部的"3324K-＞152K（3712K）"含义是“GC前该内存区域已使用容量-＞GC后该内存区域已使用容量（该内存区域总容量）”。而在方括号之外的"3324K-＞152K（11904K）"表示“GC前Java堆已使用容量-＞GC后Java堆已使用容量（Java堆总容量）”。

​	再往后，"0.0025925 secs"表示该内存区域GC所占用的时间，单位是秒。有的收集器会给出更具体的时间数据，如"[Times:user=0.01 sys=0.00，real=0.02 secs]"，这里面的user、sys和real与Linux的time命令所输出的时间含义一致，分别代表用户态消耗的CPU时间、内核态消耗的CPU事件和操作从开始到结束所经过的墙钟时间（Wall Clock Time）。

​	CPU时间与墙钟时间的区别是，墙钟时间包括各种非运算的等待耗时，例如等待磁盘I/O、等待线程阻塞，而CPU时间不包括这些耗时，但当系统有多CPU或者多核的话，多线程操作会叠加这些CPU时间，所以读者看到user或sys时间超过real时间是完全正常的。

## 3、垃圾收集器参数总结

![](D:\File\studyNote\images\par1.png)

![](D:\File\studyNote\images\par2.png)