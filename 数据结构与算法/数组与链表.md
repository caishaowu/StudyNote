## 数组

​	**数组是一种线性表结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。**==特性：支持随机访问。==

### 线性表

​	线性表的逻辑结构特性是指数据元素之间存在着线性关系。每个线性表上的数据最多只有前和后两个反向。**数组、链表、队列、栈等都是线性表结构。**

### 非线性表

​	与线性表的概念相对立，二叉树、堆、图等都是非线性表结构。

### 根据下标随机访问数组元素

```java
int[] a = new int[10];
```

![1550977236514](C:\Users\csw\AppData\Roaming\Typora\typora-user-images\1550977236514.png)

如上图，计算机给数组 a[10]分配了一块内存空间 1000~1039，其中，内存块的首地址为 base_address = 1000。

我们知道，计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址

```java
a[i]_address = base_address + i * data_type_size

```

**注意：**==数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)==。

### 低效的插入和删除

数据为了保持内存数据的连续性，会导致插入、删除这两个操作比较低效。那我们该如何解决呢？

#### 解决低效插入

1. 数组有序，必须移动元素，插入时间复杂度为 O(n)
2. 数组无序，假设插入位置为 k ，将 a[k] 放在最后，再把新元素插入，这时插入时间复杂度为 O(1)

#### 解决低效删除

在某些特殊场景下，我们并不一定追求数组的连续性。我们可以将多次删除操作集中在一起执行。

数组 a[10] 中存储了 8 个元素：a，b，c，d，e，f，g，h。现在，我们要依次删除 a，b，c 三个元素。

为了避免 d，e，f，g，h 这几个数据会被搬移三次，我们可以先**记录****下已经删除的数据**。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。

可以发现，这种思想就是 JVM 标记-清除算法的核心思想。==很多时候我们并不是要去死记硬背某个数据结构或者算法，而是要学习它背后的思想和处理技巧，这些东西才是最有价值的==

### 集合能否完全代替数组

1. Java ArrayList 无法存储基本类型，比如 int、long，需要封装为 Integer、Long 类，而Autoboxing、Unboxing 则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。
2. 如果数据大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 提供的大部分方法，也可以直接使用数组
3. 还有一个是我个人的喜好，当要表示多维数组时，用数组往往会更加直观。比如 Object\[][]array；而用容器的话则需要这样定义：ArrayList<ArrayList> array。

总结一下，对于业务开发，直接使用容器就足够了，省时省力。毕竟损耗一丢丢性能，完全不会影响到系统整体的性能。但如果你是做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器，成为首选。

## 链表

